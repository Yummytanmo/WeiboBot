<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>å¾®åšè¡ŒåŠ¨å®˜ Â· LangChain Agent æ§åˆ¶å°</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: "SF Pro Display", "PingFang SC", "Microsoft YaHei", system-ui,
          -apple-system, BlinkMacSystemFont, sans-serif;
        --bg: #f7f7fb;
        --card: #ffffff;
        --border: #e0e3ec;
        --primary: #5b67f1;
        --primary-dark: #404ae0;
        --text: #1f2430;
        --muted: #5b6171;
        --shadow: 0 12px 40px rgba(15, 23, 42, 0.08);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: var(--bg);
        color: var(--text);
      }

      .app {
        max-width: 1200px;
        margin: 0 auto;
        padding: 32px 20px 64px;
      }

      header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 20px;
        padding-bottom: 24px;
      }

      header h1 {
        margin: 0 0 8px;
        font-size: 28px;
      }

      header p {
        margin: 0;
        color: var(--muted);
        font-size: 15px;
      }

      .status-badge {
        padding: 6px 12px;
        border-radius: 999px;
        font-size: 14px;
        font-weight: 600;
        background: #f0f1fb;
        color: var(--muted);
      }

      .status-panel {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 6px;
      }

      .status-detail {
        font-size: 13px;
        color: var(--muted);
      }

      .status-badge.ready {
        background: rgba(91, 103, 241, 0.15);
        color: var(--primary-dark);
      }

      .content {
        display: grid;
        grid-template-columns: 320px 1fr;
        gap: 24px;
      }

      .panel {
        background: var(--card);
        border-radius: 20px;
        padding: 24px;
        border: 1px solid var(--border);
        box-shadow: var(--shadow);
      }

      .panel h2,
      .panel h3 {
        margin-top: 0;
        margin-bottom: 12px;
      }

      .panel h3 {
        font-size: 16px;
        color: var(--muted);
      }

      label {
        display: block;
        margin-bottom: 12px;
        font-size: 14px;
        font-weight: 600;
      }

      label span {
        display: block;
        margin-bottom: 6px;
        color: var(--muted);
        font-weight: 500;
      }

      input,
      textarea,
      select {
        width: 100%;
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 12px;
        font-size: 15px;
        background: #fff;
      }

      textarea {
        resize: none;
        min-height: 90px;
      }

      button {
        cursor: pointer;
        border-radius: 999px;
        border: none;
        padding: 12px 24px;
        font-size: 15px;
        font-weight: 600;
        transition: all 0.2s ease;
      }

      button.primary {
        background: var(--primary);
        color: #fff;
      }

      button.primary:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      button.primary:not(:disabled):hover {
        background: var(--primary-dark);
      }

      button.secondary {
        background: transparent;
        color: var(--primary-dark);
        border: 1px solid rgba(91, 103, 241, 0.4);
      }

      .chat-panel {
        display: flex;
        flex-direction: column;
        gap: 16px;
        min-height: 700px;
      }

      .chat-history {
        flex: 1;
        border: 1px solid var(--border);
        border-radius: 18px;
        padding: 16px;
        overflow-y: auto;
        background: #fafbff;
      }

      .message {
        max-width: 75%;
        padding: 12px 16px;
        border-radius: 16px;
        margin-bottom: 12px;
        line-height: 1.5;
        box-shadow: 0 6px 16px rgba(15, 23, 42, 0.08);
      }

      .message.user {
        margin-left: auto;
        background: #e8ecff;
      }

      .message.assistant {
        background: #fff;
        border: 1px solid var(--border);
      }

      .message .content {
        white-space: pre-wrap;
      }

      .message.assistant.streaming .content {
        min-height: 20px;
      }

      .cursor {
        display: inline-block;
        width: 6px;
        height: 1.2em;
        background: var(--primary);
        margin-left: 4px;
        animation: cursor-blink 1.2s steps(1) infinite;
        vertical-align: middle;
      }

      @keyframes cursor-blink {
        50% {
          opacity: 0;
        }
      }

      .message .role {
        font-size: 13px;
        font-weight: 600;
        color: var(--muted);
        margin-bottom: 6px;
      }

      .tool-log {
        border: 1px solid var(--border);
        border-radius: 18px;
        padding: 16px;
        background: #fafbff;
        max-height: 250px;
        overflow-y: auto;
      }

      .tool-entry {
        border-left: 3px solid var(--primary);
        padding-left: 12px;
        margin-bottom: 14px;
      }

      .tool-entry.running {
        border-left-color: #ffbf47;
      }

      .tool-entry.error {
        border-left-color: #ff6b6b;
      }

      .tool-entry h4 {
        margin: 0 0 6px;
        font-size: 15px;
        color: var(--primary-dark);
      }

      .tool-entry p {
        margin: 4px 0;
        font-size: 14px;
        color: var(--muted);
        word-break: break-all;
      }

      .status-chip {
        display: inline-block;
        border-radius: 999px;
        font-size: 12px;
        padding: 2px 10px;
        margin-bottom: 8px;
        background: rgba(91, 103, 241, 0.15);
        color: var(--primary-dark);
      }

      .status-chip.running {
        background: rgba(255, 191, 71, 0.2);
        color: #8c5200;
      }

      .status-chip.error {
        background: rgba(255, 107, 107, 0.2);
        color: #c0392b;
      }

      .empty-state {
        text-align: center;
        color: var(--muted);
        font-size: 14px;
        padding: 24px 0;
      }

      ul.account-list {
        padding-left: 18px;
        margin: 0 0 20px;
        color: var(--muted);
        font-size: 14px;
      }

      .tips {
        font-size: 14px;
        line-height: 1.6;
        color: var(--muted);
      }

      .actions {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        margin-top: 12px;
      }

      .toggle-row {
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 4px 0 12px;
        font-size: 14px;
        color: var(--muted);
      }

      .toggle-row input {
        width: auto;
        margin: 0;
      }

      @media (max-width: 980px) {
        .content {
          grid-template-columns: 1fr;
        }

        .panel {
          border-radius: 16px;
        }

        .message {
          max-width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <header>
        <div>
          <h1>å¾®åšè¡ŒåŠ¨å®˜ Â· LangChain Agent æ§åˆ¶å°</h1>
          <p>é…ç½® LLM æ¥å…¥ä¿¡æ¯ï¼Œå®æ—¶è§‚å¯Ÿå·¥å…·è°ƒç”¨è½¨è¿¹ï¼ŒæŒ‡æŒ¥å¾®åšè´¦å·å®Œæˆå‘å¸–ã€è¯„è®ºã€å–æ•°ç­‰ä»»åŠ¡ã€‚</p>
        </div>
        <div class="status-panel">
          <div class="status-badge" id="status-indicator">æœªè¿æ¥</div>
          <div class="status-detail" id="status-detail">ç­‰å¾…è¿æ¥</div>
        </div>
      </header>

      <div class="content">
        <section class="panel">
          <h2>è¿æ¥è®¾ç½®</h2>
          <form id="session-form">
            <label>
              <span>API Key <small style="font-weight:400;color:var(--muted)">(å¯é€‰ï¼Œç•™ç©ºè¯»å–ç¯å¢ƒå˜é‡)</small></span>
              <input
                type="password"
                id="api-key"
                placeholder="å¯ç•™ç©ºï¼Œé»˜è®¤è¯»å– YUNWU_API_KEY"
              />
            </label>
            <label>
              <span>Base URL <small style="font-weight:400;color:var(--muted)">(å¯é€‰)</small></span>
              <input
                type="text"
                id="base-url"
                placeholder="https://your-openai-compatible-endpoint/v1ï¼ˆå¯ç•™ç©ºï¼‰"
              />
            </label>
            <label>
              <span>æ¨¡å‹</span>
              <input type="text" id="model" value="gpt-4o-mini" />
            </label>
            <label>
              <span>Temperature</span>
              <input type="number" id="temperature" min="0" max="2" step="0.1" value="0.2" />
            </label>
            <label>
              <span>LLM è¶…æ—¶ï¼ˆç§’ï¼‰</span>
              <input type="number" id="llm-timeout" min="60" max="900" step="30" value="600" />
            </label>
            <label>
              <span>å·¥å…·è°ƒç”¨è¶…æ—¶ï¼ˆç§’ï¼‰</span>
              <input type="number" id="tool-timeout" min="60" max="900" step="30" value="600" />
            </label>
            <div class="toggle-row">
              <input type="checkbox" id="streaming-toggle" checked />
              <span>å¯ç”¨æµå¼è¾“å‡ºï¼ˆå±•ç¤ºå®æ—¶æ€è€ƒ / æ‰§è¡ŒçŠ¶æ€ï¼‰</span>
            </div>
            <button class="primary" type="submit" id="connect-btn">è¿æ¥æ™ºèƒ½ä½“</button>
          </form>

          <div>
            <h3>å¯ç”¨è´¦å·</h3>
            <ul class="account-list" id="account-list"></ul>
          </div>

          <div class="tips">
            <p>æç¤ºï¼š</p>
            <p>Â· é¦–æ¡æŒ‡ä»¤ä¸­è¯·æ ‡æ˜ä½¿ç”¨çš„è´¦å· IDï¼Œä¾‹å¦‚â€œè´¦å· 7828522614 æŸ¥çœ‹çƒ­é—¨â€ã€‚</p>
            <p>Â· è‹¥ä»»åŠ¡æ­¥éª¤å¤æ‚ï¼Œå¯è®©æ™ºèƒ½ä½“è‡ªè¡Œè§„åˆ’ï¼Œå®ƒä¼šæŒ‰éœ€è°ƒç”¨ weibo_action / weibo_get_state ç­‰å·¥å…·ã€‚</p>
            <p>Â· å³ä¾§å¯å›é¡¾å·¥å…·è°ƒç”¨ä¸è¿”å›ï¼Œå¿«é€Ÿå®šä½å¼‚å¸¸ã€‚</p>
          </div>
        </section>

        <section class="panel chat-panel">
          <div class="chat-history" id="chat-history">
            <div class="empty-state">è¯·å…ˆè¿æ¥æ™ºèƒ½ä½“ï¼Œç„¶ååœ¨è¿™é‡Œå¼€å§‹å¯¹è¯ã€‚</div>
          </div>

          <form id="message-form">
            <label>
              <span>è¾“å…¥æŒ‡ä»¤</span>
              <textarea id="message-input" placeholder="ç¤ºä¾‹ï¼šè´¦å· 7828522614 å‘å¾®åš åˆ†äº«ä¸€ç¯‡å…³äº AI å®‰å…¨çš„ç§‘æ™®é•¿æ–‡"></textarea>
            </label>
            <div class="actions">
              <button class="primary" type="submit" id="send-btn" disabled>å‘é€</button>
              <button class="secondary" type="button" id="reset-btn" disabled>æ¸…ç©ºä¸Šä¸‹æ–‡</button>
            </div>
          </form>

          <div class="tool-log" id="tool-logs">
            <div class="empty-state">æš‚æ— å·¥å…·è°ƒç”¨</div>
          </div>
        </section>
      </div>
    </div>

    <script>
      const STATUS_MAP = {
        idle: { label: "å·²è¿æ¥", detail: "å¾…å‘½" },
        thinking: { label: "æ€è€ƒä¸­", detail: "ğŸ§  æ™ºèƒ½ä½“æ­£åœ¨è§„åˆ’åŠ¨ä½œ" },
        thought_complete: { label: "å‡†å¤‡æ‰§è¡Œ", detail: "ğŸ§  å®Œæˆæ€è€ƒï¼Œå‡†å¤‡è°ƒç”¨å·¥å…·" },
        executing: { label: "æ‰§è¡Œä¸­", detail: "âš™ï¸ è°ƒç”¨å·¥å…·ä¸­" },
        finalizing: { label: "æ•´ç†å›å¤", detail: "ğŸ“ æ±‡æ€»æ‰§è¡Œç»“æœ" },
      };

      const state = {
        sessionId: null,
        accounts: [],
        sending: false,
        streamingEnabled: true,
        toolLogs: [],
        streamContext: {
          bubble: null,
          cursor: null,
          text: "",
        },
      };

      const toolLogMap = new Map();

      const refs = {
        statusBadge: document.getElementById("status-indicator"),
        statusDetail: document.getElementById("status-detail"),
        accountList: document.getElementById("account-list"),
        connectBtn: document.getElementById("connect-btn"),
        sendBtn: document.getElementById("send-btn"),
        resetBtn: document.getElementById("reset-btn"),
        chatHistory: document.getElementById("chat-history"),
        toolLogs: document.getElementById("tool-logs"),
        messageInput: document.getElementById("message-input"),
        streamingToggle: document.getElementById("streaming-toggle"),
        apiKey: document.getElementById("api-key"),
        baseUrl: document.getElementById("base-url"),
        model: document.getElementById("model"),
        temperature: document.getElementById("temperature"),
        llmTimeout: document.getElementById("llm-timeout"),
        toolTimeout: document.getElementById("tool-timeout"),
      };

      function setStatus(label, ready = false, detail = "") {
        refs.statusBadge.textContent = label;
        refs.statusBadge.classList.toggle("ready", ready);
        refs.statusDetail.textContent = detail || "";
      }

      function updateStatusByState(stateKey, extra = {}) {
        const preset = STATUS_MAP[stateKey] || STATUS_MAP.idle;
        let detail = preset.detail;
        if (stateKey === "executing" && extra.tool) {
          detail = `âš™ï¸ è°ƒç”¨ ${extra.tool}`;
        }
        setStatus(preset.label, true, detail);
      }

      function clearEmptyState() {
        const empty = refs.chatHistory.querySelector(".empty-state");
        if (empty) empty.remove();
      }

      function createBubbleElement(role, content) {
        const bubble = document.createElement("div");
        bubble.className = `message ${role === "user" ? "user" : "assistant"}`;
        const roleNode = document.createElement("div");
        roleNode.className = "role";
        roleNode.textContent = role === "user" ? "ç”¨æˆ·" : "å¾®åšè¡ŒåŠ¨å®˜";
        const contentNode = document.createElement("div");
        contentNode.className = "content";
        contentNode.textContent = content ?? "";
        bubble.append(roleNode, contentNode);
        return bubble;
      }

      function resetStreamContext() {
        const { cursor } = state.streamContext;
        if (cursor && cursor.parentNode) {
          cursor.remove();
        }
        state.streamContext = { bubble: null, cursor: null, text: "" };
      }

      function renderHistory(history) {
        if (!history.length) {
          refs.chatHistory.innerHTML = '<div class="empty-state">å°šæ— å¯¹è¯ã€‚</div>';
          resetStreamContext();
          return;
        }
        refs.chatHistory.innerHTML = "";
        history.forEach((msg) => {
          const bubble = createBubbleElement(msg.role, msg.content || "");
          refs.chatHistory.appendChild(bubble);
        });
        refs.chatHistory.scrollTop = refs.chatHistory.scrollHeight;
        resetStreamContext();
      }

      function renderAccountList() {
        if (!state.accounts.length) {
          refs.accountList.innerHTML = "<li>æ— å¯ç”¨è´¦å·</li>";
          return;
        }
        refs.accountList.innerHTML = state.accounts
          .map((acct) => `<li>è´¦å· IDï¼š${acct.account_id}</li>`)
          .join("");
      }

      function createParagraph(label, value) {
        const p = document.createElement("p");
        const strong = document.createElement("strong");
        strong.textContent = `${label}ï¼š`;
        const span = document.createElement("span");
        span.textContent = value || "æ— ";
        p.append(strong, span);
        return p;
      }

      function renderToolLogs() {
        if (!state.toolLogs.length) {
          refs.toolLogs.innerHTML = '<div class="empty-state">æš‚æ— å·¥å…·è°ƒç”¨</div>';
          return;
        }
        refs.toolLogs.innerHTML = "";
        state.toolLogs.forEach((entry, index) => {
          const block = document.createElement("div");
          block.className = `tool-entry ${entry.status || "done"}`;
          const title = document.createElement("h4");
          title.textContent = `${index + 1}. ${entry.tool || "å·¥å…·è°ƒç”¨"}`;
          const chip = document.createElement("span");
          chip.className = `status-chip ${entry.status || "done"}`;
          chip.textContent =
            entry.status === "running"
              ? "æ‰§è¡Œä¸­"
              : entry.status === "error"
              ? "å¤±è´¥"
              : "å®Œæˆ";
          block.append(title, chip);
          block.appendChild(createParagraph("å…¥å‚", entry.input || ""));
          if (entry.log) {
            block.appendChild(createParagraph("æ—¥å¿—", entry.log));
          }
          if (entry.output) {
            block.appendChild(
              createParagraph(entry.status === "error" ? "å¼‚å¸¸" : "è¿”å›", entry.output)
            );
          }
          refs.toolLogs.appendChild(block);
        });
      }

      function resetToolLogs() {
        state.toolLogs = [];
        toolLogMap.clear();
        renderToolLogs();
      }

      function appendUserMessage(content) {
        clearEmptyState();
        const bubble = createBubbleElement("user", content);
        refs.chatHistory.appendChild(bubble);
        refs.chatHistory.scrollTop = refs.chatHistory.scrollHeight;
      }

      function startAssistantStream() {
        clearEmptyState();
        const bubble = createBubbleElement("assistant", "");
        bubble.classList.add("streaming");
        const cursor = document.createElement("span");
        cursor.className = "cursor";
        const contentNode = bubble.querySelector(".content");
        contentNode.textContent = "";
        contentNode.appendChild(cursor);
        state.streamContext = { bubble, cursor, text: "" };
        refs.chatHistory.appendChild(bubble);
        refs.chatHistory.scrollTop = refs.chatHistory.scrollHeight;
      }

      function appendAssistantToken(token) {
        const { bubble, cursor } = state.streamContext;
        if (!bubble || !cursor) return;
        state.streamContext.text += token;
        const contentNode = bubble.querySelector(".content");
        if (cursor.parentNode) {
          cursor.remove();
        }
        contentNode.textContent = state.streamContext.text;
        contentNode.appendChild(cursor);
        refs.chatHistory.scrollTop = refs.chatHistory.scrollHeight;
      }

      function finishAssistantStream(finalText) {
        const { bubble, cursor, text } = state.streamContext;
        if (!bubble) return;
        if (cursor && cursor.parentNode) {
          cursor.remove();
        }
        const contentNode = bubble.querySelector(".content");
        contentNode.textContent = typeof finalText === "string" ? finalText : text;
        bubble.classList.remove("streaming");
        resetStreamContext();
      }

      function handleToolStart(payload) {
        const entry = {
          id: payload.id,
          tool: payload.tool || "å·¥å…·è°ƒç”¨",
          input: payload.input || "",
          status: "running",
          output: "",
          log: "",
        };
        toolLogMap.set(entry.id, entry);
        state.toolLogs.push(entry);
        renderToolLogs();
      }

      function handleToolResult(payload) {
        const entry = toolLogMap.get(payload.id);
        if (!entry) return;
        entry.status = payload.error ? "error" : "done";
        entry.output = payload.error || payload.output || "";
        renderToolLogs();
      }

      function replaceToolLogsFromSteps(steps) {
        toolLogMap.clear();
        if (!steps || !steps.length) {
          state.toolLogs = [];
          renderToolLogs();
          return;
        }
        state.toolLogs = steps.map((step, index) => {
          const entry = {
            id: `step-${index}`,
            tool: step.tool || `æ­¥éª¤ ${index + 1}`,
            input: step.input || "",
            log: step.log || "",
            output: step.observation || "",
            status: "done",
          };
          toolLogMap.set(entry.id, entry);
          return entry;
        });
        renderToolLogs();
      }

      function handleFinalEvent(payload) {
        finishAssistantStream(payload.output || "");
        renderHistory(payload.history || []);
        replaceToolLogsFromSteps(payload.steps || []);
        setStatus("å·²è¿æ¥", true, "å¾…å‘½");
        state.sending = false;
        refs.sendBtn.disabled = false;
        refs.resetBtn.disabled = false;
      }

      function handleStreamError(message) {
        finishAssistantStream("");
        setStatus("æ‰§è¡Œå¤±è´¥", false, message || "è¯·æŸ¥çœ‹åç«¯æ—¥å¿—");
        state.sending = false;
        refs.sendBtn.disabled = false;
        refs.resetBtn.disabled = false;
        alert(`æ‰§è¡Œå¤±è´¥ï¼š${message}`);
      }

      function handleStatusEvent(payload) {
        if (!payload || !payload.state) return;
        updateStatusByState(payload.state, payload);
      }

      function handleStreamEvent(event) {
        if (!event || !event.type) return;
        switch (event.type) {
          case "status":
            handleStatusEvent(event.payload);
            break;
          case "token":
            appendAssistantToken(event.payload?.content || "");
            break;
          case "tool_start":
            handleToolStart(event.payload || {});
            break;
          case "tool_result":
            handleToolResult(event.payload || {});
            break;
          case "final":
            handleFinalEvent(event.payload || {});
            break;
          case "error":
            handleStreamError(event.payload?.message || "æœªçŸ¥é”™è¯¯");
            break;
          default:
            break;
        }
      }

      async function streamChatRequest(message) {
        updateStatusByState("thinking");
        const res = await fetch("/api/chat/stream", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            session_id: state.sessionId,
            message,
          }),
        });
        if (!res.ok) {
          throw new Error(await res.text());
        }
        const reader = res.body?.getReader();
        if (!reader) {
          throw new Error("æµè§ˆå™¨ä¸æ”¯æŒæµå¼è¯»å–");
        }
        const decoder = new TextDecoder("utf-8");
        let buffer = "";
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });
          let newlineIndex;
          while ((newlineIndex = buffer.indexOf("\n")) >= 0) {
            const line = buffer.slice(0, newlineIndex).trim();
            buffer = buffer.slice(newlineIndex + 1);
            if (!line) continue;
            try {
              handleStreamEvent(JSON.parse(line));
            } catch (err) {
              console.error("è§£ææµå¤±è´¥", err, line);
            }
          }
        }
        buffer += decoder.decode();
        const remaining = buffer.trim();
        if (remaining) {
          try {
            handleStreamEvent(JSON.parse(remaining));
          } catch (err) {
            console.error("è§£æå‰©ä½™æµå¤±è´¥", err, remaining);
          }
        }
      }

      async function sendWithoutStreaming(message) {
        try {
          updateStatusByState("thinking");
          const res = await fetch("/api/chat", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              session_id: state.sessionId,
              message,
            }),
          });
          if (!res.ok) throw new Error(await res.text());
          const data = await res.json();
          renderHistory(data.history || []);
          replaceToolLogsFromSteps(data.steps || []);
          setStatus("å·²è¿æ¥", true, "å¾…å‘½");
        } catch (err) {
          console.error(err);
          setStatus("æ‰§è¡Œå¤±è´¥", false, "è¯·æŸ¥çœ‹åç«¯æ—¥å¿—");
          alert("æ‰§è¡Œå¤±è´¥ï¼Œè¯·æŸ¥çœ‹åç«¯æ—¥å¿—æˆ–æ£€æŸ¥å·¥å…·é…ç½®ã€‚");
        } finally {
          state.sending = false;
          refs.sendBtn.disabled = false;
          refs.resetBtn.disabled = false;
        }
      }

      async function sendMessage(event) {
        event.preventDefault();
        if (!state.sessionId) {
          alert("è¯·å…ˆè¿æ¥æ™ºèƒ½ä½“");
          return;
        }
        if (state.sending) return;
        const content = refs.messageInput.value.trim();
        if (!content) return;
        refs.messageInput.value = "";
        appendUserMessage(content);
        resetToolLogs();
        state.sending = true;
        refs.sendBtn.disabled = true;
        refs.resetBtn.disabled = true;
        if (state.streamingEnabled) {
          startAssistantStream();
          try {
            await streamChatRequest(content);
          } catch (err) {
            console.error(err);
            handleStreamError(err.message || "ç½‘ç»œå¼‚å¸¸");
          }
        } else {
          await sendWithoutStreaming(content);
        }
      }

      async function fetchConfig() {
        try {
          const res = await fetch("/api/config");
          if (!res.ok) throw new Error("è·å–é…ç½®å¤±è´¥");
          const data = await res.json();
          state.accounts = data.accounts || [];
          renderAccountList();
          if (data.defaults) {
            refs.model.value = data.defaults.model;
            refs.temperature.value = data.defaults.temperature;
            if (data.defaults.llm_timeout) {
              refs.llmTimeout.value = data.defaults.llm_timeout;
            }
            if (data.defaults.tool_timeout) {
              refs.toolTimeout.value = data.defaults.tool_timeout;
            }
          }
        } catch (err) {
          console.error(err);
        }
      }

      async function createSession(event) {
        event.preventDefault();
        const payload = {
          api_key: refs.apiKey.value.trim(),
          base_url: refs.baseUrl.value.trim(),
          model: refs.model.value.trim() || "gpt-4o-mini",
          temperature: Number(refs.temperature.value) || 0.2,
          llm_timeout: Number(refs.llmTimeout.value) || 600,
          tool_timeout: Number(refs.toolTimeout.value) || 600,
          streaming: refs.streamingToggle.checked,
        };
        refs.connectBtn.disabled = true;
        setStatus("è¿æ¥ä¸­...", false, "æ­£åœ¨åˆå§‹åŒ– LangChain æ™ºèƒ½ä½“");
        try {
          const res = await fetch("/api/session", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          if (!res.ok) throw new Error(await res.text());
          const data = await res.json();
          state.sessionId = data.session_id;
          state.streamingEnabled = data.streaming !== false;
          renderHistory(data.history || []);
          resetToolLogs();
          setStatus(
            "å·²è¿æ¥",
            true,
            state.streamingEnabled ? "æµå¼è¾“å‡ºå·²å¯ç”¨" : "å½“å‰ä¸ºæ ‡å‡†æ¨¡å¼"
          );
          refs.sendBtn.disabled = false;
          refs.resetBtn.disabled = false;
        } catch (err) {
          console.error(err);
          setStatus("è¿æ¥å¤±è´¥", false, "è¯·æ£€æŸ¥ API Key / Base URL é…ç½®");
          alert("åˆ›å»ºä¼šè¯å¤±è´¥ï¼Œè¯·æ£€æŸ¥å‚æ•°æˆ–æŸ¥çœ‹åç«¯æ—¥å¿—ã€‚");
        } finally {
          refs.connectBtn.disabled = false;
        }
      }

      async function resetSession() {
        if (!state.sessionId) return;
        refs.resetBtn.disabled = true;
        try {
          const res = await fetch("/api/session/reset", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ session_id: state.sessionId }),
          });
          if (!res.ok) throw new Error(await res.text());
          const data = await res.json();
          renderHistory(data.history || []);
          resetToolLogs();
          setStatus("ä¸Šä¸‹æ–‡å·²æ¸…ç©º", true, "å¯ä»¥ç»§ç»­è¾“å…¥æ–°æŒ‡ä»¤");
        } catch (err) {
          console.error(err);
          setStatus("æ¸…ç©ºå¤±è´¥", false, "è¯·ç¨åé‡è¯•");
          alert("é‡ç½®å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚");
        } finally {
          refs.resetBtn.disabled = false;
        }
      }

      document.getElementById("session-form").addEventListener("submit", createSession);
      document.getElementById("message-form").addEventListener("submit", sendMessage);
      document.getElementById("reset-btn").addEventListener("click", resetSession);

      fetchConfig();
      setStatus("æœªè¿æ¥", false, "ç­‰å¾…è¿æ¥");
    </script>
  </body>
</html>
